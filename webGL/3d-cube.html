<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Programming 3D applications in HTML5 and WebGL &mdash; Example 2-2</title>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
		<script src="lib/gl-matrix-min.js"></script>
		<script type="text/javascript">
			function initWebGL(canvas) {
			    var gl = null;
			    var msg = "Your browser does not support WebGL, " +
			    	"or it is not enabled by default.";
			    try {
			        gl = canvas.getContext("experimental-webgl");
			    } catch (e) {
			        msg = "Error creating WebGL Context!: " + e.toString();
			    }
			
			    if (!gl) {
				    alert(msg);
			    	throw new Error(msg);
			    }

		        return gl;        
		     }

		    function initViewport(gl, canvas) {
		        gl.viewport(0, 0, canvas.width, canvas.height);
		    }

		    var projectionMatrix, modelViewMatrix;

		    function initMatrices(canvas) {
		        // Create a model view matrix with object at 0, 0, -3.333
		        modelViewMatrix = mat4.create();
		        mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -3.333]);

		        // Create a project matrix with 45 degree field of view
		        projectionMatrix = mat4.create();
		        mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 1, 10000);
		    }

			// Create the vertex, color, and index data for a multicolored cube
			function createCube(gl) {

				// Vertex Data
				var vertexBuffer;
				vertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				var verts = [
					// Front face
					-1.0, 	-1.0,	 1.0,
					 1.0,	-1.0,	 1.0,
					 1.0, 	 1.0,	 1.0,
					-1.0,	 1.0, 	 1.0,

					// Back face
					-1.0,	-1.0, 	-1.0,
					-1.0,	 1.0,	-1.0,
					 1.0, 	 1.0, 	-1.0,
					 1.0, 	-1.0, 	-1.0,

					// Top face
					-1.0, 	 1.0, 	-1.0,
					-1.0, 	 1.0, 	 1.0,
					 1.0, 	 1.0, 	 1.0,
					 1.0, 	 1.0, 	-1.0,

					// Bottom face
					-1.0, 	-1.0, 	-1.0,
					 1.0, 	-1.0, 	-1.0,
					 1.0, 	-1.0, 	 1.0,
					-1.0, 	-1.0, 	 1.0,

					// Right face
					 1.0, 	-1.0, 	-1.0,
					 1.0, 	 1.0, 	-1.0,
					 1.0, 	 1.0, 	 1.0,
					 1.0, 	-1.0, 	 1.0,

					// Left face
					-1.0, 	-1.0, 	-1.0,
					-1.0, 	-1.0, 	 1.0,
					-1.0, 	 1.0, 	 1.0,
					-1.0, 	 1.0,   -1.0
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);

				// Color data
				var colorBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
				var faceColors = [
					[1.0, 0.0, 0.0, 1.0], 	// Front face
					[0.0, 1.0, 0.0, 1.0], 	// Back face
					[0.0, 0.0, 1.0, 1.0], 	// Top face
					[1.0, 1.0, 0.0, 1.0], 	// Bottom face
					[1.0, 0.0, 1.0, 1.0], 	// Right face
					[0.0, 1.0, 1.0, 1.0] 	// Left face
				];
				vertexColors = [];
				for (var i in faceColors) {
					var color = faceColors[i];
					for (var j = 0; j < 4; j++) {
						vertexColors = vertexColors.concat(color);
					}
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexColors),
					gl.STATIC_DRAW);

				// Index data (defines the traingles to be drawn)
				var cubeIndexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
				var cubeIndices = [
					0, 1, 2,	0, 2, 3, 	// Front face
					4, 5, 6, 	4, 6, 7, 	// Back face
					8, 9, 10,	8, 10, 11,  // Top face
					12, 13, 14, 12, 14, 15, // Bottom face
					16, 17, 18, 16, 18, 19, // Right face
					20, 21, 22, 20, 22, 23  // Left face
				];
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeIndices),
					gl.STATIC_DRAW);

				var cube = {buffer: vertexBuffer, colorBuffer: colorBuffer,
					indices: cubeIndexBuffer,
						vertSize: 3, nVerts: 24, colorSize: 4, nColors:24, nIndices: 36,
						primtype: gl.TRIANGLES};

				return cube;
			}

			var vertexShaderSource = 

				"	attribute vec3 vertexPos;\n" +
				"	attribute vec4 vertexColor;\n" +
				"	uniform mat4 modelViewMatrix;\n" +
				" 	uniform mat4 projectionMatrix;\n" +
				"	varying vec4 vColor;\n"	+
				"	void main(void) {\n" +
				"		// Return the transformed and projected vertex value\n" +
				"		gl_Position = projectionMatrix * modelViewMatrix * \n" +
				"			vec4(vertexPos, 1.0);\n" +
				"		// Output the vertexColor in vColor\n" +
				"		vColor = vertexColor;\n" +
				"	}\n";

			var fragmentShaderSource = 

				"	precision mediump float;\n" +
				"	varying vec4 vColor;\n" +
				"	void main(void) {\n" +
				"		// Return the pixel color: always output white\n" +
				"		gl_FragColor = vColor;\n" +
				"	}\n";

			function draw(gl, obj) {
				// clear the background (with black)
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// set the shader to use
				gl.useProgram(shaderProgram);

				// connect up the shader parameters: vertex position,
				// color, and projection/model matrices
				// set up the buffers
				gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer);
				gl.vertexAttribPointer(shaderVertexPositionAttribute,
					obj.vertSize, gl.FLOAT, false, 0.0);
				gl.bindBuffer(gl.ARRAY_BUFFER, obj.colorBuffer);
				gl.vertexAttribPointer(shaderVertexColorAttribute, 
					obj.colorSize, gl.FLOAT, false, 0.0);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.indices);

				gl.uniformMatrix4fv(shaderProjectionMatrixUniform, false, 
					projectionMatrix);
				gl.uniformMatrix4fv(shaderModelViewMatrixUniform, false,
					modelViewMatrix);

				// draw the object
				gl.drawElements(obj.primtype, obj.nIndices, gl.UNSIGNED_SHORT, 0);
			}
		</script>
	</head>
	<body>
	    <canvas id="webglcanvas" style="border: none;" width="500" height="500"></canvas>
	</body>
</html>